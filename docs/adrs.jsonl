{"id":"ADR-001","title":"Logging Library","status":"approved","decision":"tslog over console.log/pino/winston","rationale":"TypeScript-native with full type safety, zero dependencies, structured JSON logging, pretty console output, minimal config, tree-shakeable","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-002","title":"TypeScript Strict Mode","status":"approved","decision":"strict: true enabled in tsconfig","rationale":"Catches bugs at compile time, enforces explicit types, prevents implicit any","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-003","title":"Dead Code Detection","status":"approved","decision":"Knip for finding unused files, dependencies, and exports","rationale":"Modern comprehensive tool for detecting dead code, finds unused files/dependencies/exports/types, excellent monorepo and React support, integrates with TypeScript project references, configurable via knip.json, supports barrel file entry points for public APIs","createdAt":"2025-11-28","updatedAt":"2025-11-28"}
{"id":"ADR-004","title":"AI-Focused CLI Design","status":"approved","decision":"JSON output by default with self-describing interfaces","rationale":"Following AI-focused CLI best practices: JSON output by default for machine consumption, structured error responses with HTTP-style codes, self-describing interfaces via --api-version/--schema/--list-commands, semantic exit codes (0=success, 1=user error, 2=system error), human-friendly output as opt-in via --format=text|table, non-interactive operation for CI/CD and AI agents","createdAt":"2025-11-28","updatedAt":"2025-11-28"}
{"id":"ADR-005","title":"Standardized README.md as First-Class Developer Interface","status":"approved","decision":"We will treat README.md as a first-class interface for developers and enforce a standardized minimal structure for all repositories. Every project MUST include at least: (1) Project Identity (name, one-line summary, motivation); (2) Quickstart section with requirements, install steps, and a minimal run/usage example; (3) Project Structure overview with a short description of main modules; (4) Configuration & Environment (env vars, .env.example, defaults); (5) Development Workflow (how to run tests, build, and contribution basics); (6) Deployment notes when applicable; (7) Contact/Maintainers info. Additional sections (FAQ, Changelog, Roadmap, Design Principles, Known Issues) are OPTIONAL but RECOMMENDED when they materially reduce questions and onboarding time.","rationale":"A well-structured README significantly reduces onboarding time, cognitive load, and reliance on tribal knowledge. It acts as the primary contract between the codebase and its consumers/contributors. Standardizing a minimal structure ensures that every repository exposes the same essential information: what the project is, how to run it quickly, how it is structured, how to configure it, and how to contribute. This consistency improves developer experience, makes repositories self-service, and minimizes repeated questions about setup and usage. It also supports future automation (e.g., bots and tools parsing README sections) because the structure becomes predictable.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["documentation","readme","developer-experience","standards"],"context":"Our repositories are consumed by multiple stakeholders: internal developers, external contributors, automation tools, and sometimes non-technical collaborators. Inconsistent or incomplete READMEs increase onboarding friction, cause misalignment on project scope, and slow down debugging and maintenance. Some projects currently have outdated or minimal READMEs that do not reflect the real setup or architecture, leading to time wasted reading code to answer basic questions. We need a standard that balances completeness with pragmatism and can be maintained over time.","consequences":{"positive":["New developers and contributors can understand and run the project in minutes using the Quickstart section.","Consistent structure across repositories reduces cognitive overhead when switching between projects.","Troubleshooting and maintenance are faster because configuration, environment variables, and workflows are documented in a predictable place.","Automation tools (e.g., documentation bots, discovery/indexing scripts) can rely on a stable README layout to extract metadata or commands.","Clear expectations around minimal sections reduce discussions about what belongs in documentation vs. separate design docs."],"negative":["Maintainers must keep the README updated; an outdated standardized README can create a false sense of reliability and become actively harmful.","Initial setup effort is required to retrofit existing repositories to the new standard.","Overly verbose READMEs may appear if teams try to put full design docs into README instead of linking out, which can reduce readability.","Enforcement (via PR templates or checks) may be perceived as overhead by smaller or experimental projects."]}}
