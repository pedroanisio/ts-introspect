{"id":"ADR-001","title":"Logging Library","status":"approved","decision":"tslog over console.log/pino/winston","rationale":"TypeScript-native with full type safety, zero dependencies, structured JSON logging, pretty console output, minimal config, tree-shakeable","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-002","title":"TypeScript Strict Mode","status":"approved","decision":"strict: true enabled in tsconfig","rationale":"Catches bugs at compile time, enforces explicit types, prevents implicit any","createdAt":"2025-11-27","updatedAt":"2025-11-27"}
{"id":"ADR-003","title":"Dead Code Detection","status":"approved","decision":"Knip for finding unused files, dependencies, and exports","rationale":"Modern comprehensive tool for detecting dead code, finds unused files/dependencies/exports/types, excellent monorepo and React support, integrates with TypeScript project references, configurable via knip.json, supports barrel file entry points for public APIs","createdAt":"2025-11-28","updatedAt":"2025-11-28"}
{"id":"ADR-004","title":"AI-Focused CLI Design","status":"approved","decision":"JSON output by default with self-describing interfaces","rationale":"Following AI-focused CLI best practices: JSON output by default for machine consumption, structured error responses with HTTP-style codes, self-describing interfaces via --api-version/--schema/--list-commands, semantic exit codes (0=success, 1=user error, 2=system error), human-friendly output as opt-in via --format=text|table, non-interactive operation for CI/CD and AI agents","createdAt":"2025-11-28","updatedAt":"2025-11-28"}
{"id":"ADR-005","title":"Standardized README.md as First-Class Developer Interface","status":"approved","decision":"We will treat README.md as a first-class interface for developers and enforce a standardized minimal structure for all repositories. Every project MUST include at least: (1) Project Identity (name, one-line summary, motivation); (2) Quickstart section with requirements, install steps, and a minimal run/usage example; (3) Project Structure overview with a short description of main modules; (4) Configuration & Environment (env vars, .env.example, defaults); (5) Development Workflow (how to run tests, build, and contribution basics); (6) Deployment notes when applicable; (7) Contact/Maintainers info. Additional sections (FAQ, Changelog, Roadmap, Design Principles, Known Issues) are OPTIONAL but RECOMMENDED when they materially reduce questions and onboarding time.","rationale":"A well-structured README significantly reduces onboarding time, cognitive load, and reliance on tribal knowledge. It acts as the primary contract between the codebase and its consumers/contributors. Standardizing a minimal structure ensures that every repository exposes the same essential information: what the project is, how to run it quickly, how it is structured, how to configure it, and how to contribute. This consistency improves developer experience, makes repositories self-service, and minimizes repeated questions about setup and usage. It also supports future automation (e.g., bots and tools parsing README sections) because the structure becomes predictable.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["documentation","readme","developer-experience","standards"],"context":"Our repositories are consumed by multiple stakeholders: internal developers, external contributors, automation tools, and sometimes non-technical collaborators. Inconsistent or incomplete READMEs increase onboarding friction, cause misalignment on project scope, and slow down debugging and maintenance. Some projects currently have outdated or minimal READMEs that do not reflect the real setup or architecture, leading to time wasted reading code to answer basic questions. We need a standard that balances completeness with pragmatism and can be maintained over time.","consequences":{"positive":["New developers and contributors can understand and run the project in minutes using the Quickstart section.","Consistent structure across repositories reduces cognitive overhead when switching between projects.","Troubleshooting and maintenance are faster because configuration, environment variables, and workflows are documented in a predictable place.","Automation tools (e.g., documentation bots, discovery/indexing scripts) can rely on a stable README layout to extract metadata or commands.","Clear expectations around minimal sections reduce discussions about what belongs in documentation vs. separate design docs."],"negative":["Maintainers must keep the README updated; an outdated standardized README can create a false sense of reliability and become actively harmful.","Initial setup effort is required to retrofit existing repositories to the new standard.","Overly verbose READMEs may appear if teams try to put full design docs into README instead of linking out, which can reduce readability.","Enforcement (via PR templates or checks) may be perceived as overhead by smaller or experimental projects."]}}
{"id":"ADR-006","title":"Code Markers Convention (TODO, FIX, HACK, etc.)","status":"approved","decision":"We adopt a two-tier marker system for code annotations. Tier 1 uses short-lived inline markers (TODO, FIXME, HACK, XXX) that are only allowed during active development and must be resolved or promoted to structured metadata before a PR is merged. Tier 2 uses persistent structured entries in __metadata.todos and __metadata.fixes for any work, enhancement, or defect that should outlive the current work session. We standardize marker semantics, priority/severity levels, ID formats (TODO-NNN, FIX-NNN), lifecycle and retention policies, forbidden markers, and a PR checklist, and we rely on ts-introspect (including rules like metadata/untracked-todos) and tsi CLI commands to enforce and report on these conventions.","rationale":"Unstructured code markers like TODO, FIXME, HACK, and XXX tend to accumulate over time without ownership, priority, or clear lifecycle, creating invisible technical debt, noise in the codebase, and lack of accountability. Different teams and individuals use arbitrary comment formats, making it difficult to search, aggregate, or reason about outstanding work and known defects. Since ts-introspect already provides structured metadata capabilities, adopting a standardized two-tier model enables us to keep code clean while still tracking long-lived work in a queryable and reportable form. This balances the need for lightweight, local notes during development with the requirement for durable, structured tracking across the project.","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["code-markers","todo","fixme","technical-debt","ts-introspect","conventions"],"context":"Code markers like TODO, FIXME, HACK, and XXX are widely used in our codebase but, without conventions, they lead to lost context, invisible technical debt, stale comments, lack of ownership, and inconsistent searchability. We now have ts-introspect, which can track todos and fixes via __metadata. To leverage this system effectively, we need clear rules for when to use inline markers vs. structured metadata, how to prioritize and classify work, and how to ensure markers do not become permanent clutter in the source code.","consequences":{"positive":["All planned work and known defects are captured in structured metadata and can be queried via the tsi CLI and reports.","Ownership, priority, severity, and lifecycle of todos and fixes are explicit, improving accountability and planning.","Inline comments remain clean and focused on local code readability, avoiding long-lived, stale markers.","HTML and other reports can be generated from __metadata to support planning, dashboards, and reviews.","Pre-commit hooks and metadata/untracked-todos validation rules can automatically catch violations and enforce the conventions.","IDE snippets and templates can make metadata entry fast, making the workflow natural during development."],"negative":["Developers must spend additional effort promoting inline markers into structured metadata when work needs to persist.","There is a learning curve for the team to internalize the new marker taxonomy, ID conventions, and lifecycle rules.","The workflow depends on ts-introspect and related tooling; if tooling is misconfigured or unavailable, the process weakens.","If the conventions are not followed consistently, we risk divergence between inline comments, metadata, and actual code state."]}}
{"id":"ADR-007","title":"Code Quality and Project Practices","status":"approved","decision":"Adopt DRY, SOLID principles, Design Patterns, and Architectural Elegance while prioritizing Ship Fast philosophy","rationale":"Sustainable, maintainable code requires adherence to proven engineering principles balanced with pragmatic delivery goals","createdAt":"2025-11-28","updatedAt":"2025-11-28","tags":["code-quality","best-practices","architecture","engineering-principles"],"context":"As the codebase grows, maintaining consistency and quality becomes critical. Without clear guidelines, technical debt accumulates, onboarding slows, and the system becomes brittle. We need explicit principles that guide daily decisions without over-engineering.","consequences":{"positive":["Consistent codebase that any team member can navigate and extend","Reduced bugs through proper abstractions and separation of concerns","Faster feature development through reusable, well-designed components","Easier code reviews with shared vocabulary and expectations","Sustainable velocity over time"],"negative":["Initial learning curve for team members unfamiliar with these principles","Risk of over-engineering if principles are applied dogmatically","Requires ongoing vigilance and code review discipline"]},"principles":{"DRY":"Don't Repeat Yourself - Extract common logic into shared utilities, components, and modules. Every piece of knowledge should have a single, authoritative representation. Duplication is the root of maintenance nightmares.","SOLID":{"S":"Single Responsibility - Each module, class, or function should have one reason to change. Keep units focused and cohesive.","O":"Open/Closed - Code should be open for extension but closed for modification. Use composition, interfaces, and dependency injection.","L":"Liskov Substitution - Subtypes must be substitutable for their base types without altering correctness. Honor contracts.","I":"Interface Segregation - Prefer small, focused interfaces over large, monolithic ones. Clients should not depend on methods they don't use.","D":"Dependency Inversion - Depend on abstractions, not concretions. High-level modules should not depend on low-level modules."},"DesignPatterns":"Apply proven design patterns (Factory, Strategy, Observer, Decorator, etc.) where they genuinely simplify code. Patterns are tools, not goals - use them to solve real problems, not to demonstrate cleverness.","ArchitecturalElegance":"Strive for clean, intuitive architecture that reveals intent. Code should be self-documenting through clear naming, logical structure, and minimal surprise. Complexity should be encapsulated, not scattered. The architecture should guide developers toward the pit of success.","ShipFast":"Perfect is the enemy of good. Deliver working software iteratively. Avoid over-engineering and premature optimization. Make pragmatic tradeoffs - 80% solution today beats 100% solution never. Refactor when patterns emerge, not in anticipation. Technical excellence enables speed; it doesn't compete with it."}}